<center><h1>第十天</h1></center>

####二叉搜索树
这道题采用了数组来存储元素，
left=root*2,right=root*2;
这种形式若树的节点较少或者比较有规律的时候可以采用

####最短路径
最短路径这道题，一个是用常规的最小路径算法来做，但处理起来相当麻烦（涉及到高精度整数运算）
另外一种方法，由于这里的边长是2的指数增长，所以出现两个节点间出现一个中间节点时，直接使用中间节点加上中间节点到目标节点的边长代替两节点的最小长度。（例如1+2<4）
这相当于MST生成算法，当生成最小生成树时，指定节点到各个节点的长度最小。
这里采用二维数组来记录dist比较合适，被选中的边的两个点需要分别在两个不同的集合

            if(x!=y) {
				int dist=nums[i];
				for(int j=0; j<n; j++) {
					if(x==FindRoot(j)) {
						for(int k=0; k<n; k++) {
							if(y==FindRoot(k)) {
								dis[j][k]=dis[k][j]=(dis[j][start]+dis[end][k]+dist)%100000;
							}
						}
					}

				}
				Tree[y]=x;
			}